extern "C"
{
#include "raylib.h"
#include "raymath.h"
//#define RAYGUI_IMPLEMENTATION
//#include "raygui.h"
}

#include "character.hpp"
#include "controller.hpp"
#include "curve.hpp"
#include "database.hpp"
#include "ik.hpp"
#include "motion.hpp"
#include "nnet.hpp"
#include "renderer.hpp"
#include "robot.hpp"

enum
{
    GAMEPAD_PLAYER = 0,
};

enum
{
    GAMEPAD_STICK_LEFT,
    GAMEPAD_STICK_RIGHT,
};

vec3 gamepad_get_stick(int stick, const float deadzone = 0.2f)
{
    float gamepadx = GetGamepadAxisMovement(GAMEPAD_PLAYER, stick == GAMEPAD_STICK_LEFT ? GAMEPAD_AXIS_LEFT_X : GAMEPAD_AXIS_RIGHT_X);
    float gamepady = GetGamepadAxisMovement(GAMEPAD_PLAYER, stick == GAMEPAD_STICK_LEFT ? GAMEPAD_AXIS_LEFT_Y : GAMEPAD_AXIS_RIGHT_Y);
    float gamepadmag = sqrtf(gamepadx*gamepadx + gamepady*gamepady);
    
    if (gamepadmag > deadzone)
    {
        float gamepaddirx = gamepadx / gamepadmag;
        float gamepaddiry = gamepady / gamepadmag;
        float gamepadclippedmag = gamepadmag > 1.0f ? 1.0f : gamepadmag*gamepadmag;
        gamepadx = gamepaddirx * gamepadclippedmag;
        gamepady = gamepaddiry * gamepadclippedmag;
    }
    else
    {
        gamepadx = 0.0f;
        gamepady = 0.0f;
    }
    
    return vec3(gamepadx, 0.0f, gamepady);
}

int main(int argc, char** argv)
{
    InitWindow(720, 720, "raylib [background]");
    SetTargetFPS(60);
    
    // float frequency;
    // float halflife;
    // frequency = GuiSliderBar((Rectangle){ 100, 20, 120, 20 }, "frequency", TextFormat("%5.3f", frequency), frequency, 0.0f, 3.0f);
    // halflife = GuiSliderBar((Rectangle){ 100, 45, 120, 20 }, "halflife", TextFormat("%5.3f", halflife), halflife, 0.0f, 1.0f);

    //相机
    MooCamera camera(1, 0.1f, 0.1f, 0.05f, 50.f, vec3(0.f, 1.2f, - 3.f), mat3());
    camera.set_view(vec3(0.f, 0.f, 1.f));
    camera.update_orientation(vec3(0.f, 1.f, 0.f));
<<<<<<< HEAD
=======
<<<<<<< HEAD
>>>>>>> 4df4acd (v1.02)
    //控制器
    Controller controller;
    bind_controller(controller, &camera.position, &camera.direction);
    //角色，保存原始所有信息
    Character character;
    character_load(character, "../resources/character.bin");
<<<<<<< HEAD
=======
=======
>>>>>>> 5e7c086 (v1.02)
>>>>>>> 4df4acd (v1.02)
    //机器人
    Robot robot;
    robot_load(robot, "../resources/robot.bin");
    // robot = create_robot(0.4f, 5.f, 18, 50, 10, 0.8f);
    // robot_save(robot, "../resources/robot.bin");
    //对角色数据的拷贝
<<<<<<< HEAD
=======
<<<<<<< HEAD
>>>>>>> 4df4acd (v1.02)
    MooMesh mesh1 = make_character_rest_mesh(character);
    MooMesh mesh2 = make_robot_rest_mesh(robot);
    MooMesh mesh3 = cube();
    //材质
    MooMaterial material1(PBR);
    material1.roughness = 0.1f;
    material1.tex = img_to_tex("../resources/texture.png");
    material1.BRDFLut = img_to_tex("../resources/BRDFLut.png");
    material1.EavgLut = img_to_tex("../resources/EavgLut.png");
    MooMaterial material2(PBR);
    material2.roughness = 0.75f;
    material2.tex = img_to_tex("../resources/texture.png");
    material2.BRDFLut = img_to_tex("../resources/BRDFLut.png");
    material2.EavgLut = img_to_tex("../resources/EavgLut.png");
    MooMaterial material3(TEXTURE);
    material3.roughness = 0.5f;
    material3.tex = img_to_tex("../resources/skybox.png");
    material3.BRDFLut = img_to_tex("../resources/BRDFLut.png");
    material3.EavgLut = img_to_tex("../resources/EavgLut.png");
    //model存储mesh的拷贝，但由于mesh本身存储的是地址，实际上仍为mesh地址上的数据
    MooModel model1 = mesh_material_to_model(mesh1, material1);
    MooModel model2 = mesh_material_to_model(mesh2, material2);
    MooModel model3 = mesh_material_to_model(mesh3, material3);
    //动作库
    BVH_Motion motion, motion1, motion2, motion3, motion4, motion5, motion6;
    Motion_load(motion, "../resources/long_motion.bin");
    motion1 = motion_sub_sequence(motion, 0, 50);
    motion2 = motion_sub_sequence(motion, 300, 350);
    motion3 = translation_and_rotation(motion1, 0, vec3(0.f, 0.5f, 0.f), vec3(0.f, 0.f, -1.f));
    motion4 = translation_and_rotation(motion2, 0, vec3(0.f, 0.5f, 0.f), vec3(-1.f, 0.f, 0.f));
    motion5 = motion_concatenate(motion3, motion4);
<<<<<<< HEAD
=======
=======
    MooMesh mesh1 = make_robot_rest_mesh(robot);
    //材质
    MooMaterial material1(PBR);
    material1.roughness = 0.75f;
    material1.tex = img_to_tex("../resources/texture.png");
    material1.BRDFLut = img_to_tex("../resources/BRDFLut.png");
    material1.EavgLut = img_to_tex("../resources/EavgLut.png");
    //model存储mesh的拷贝，但由于mesh本身存储的是地址，实际上仍为mesh地址上的数据
    MooModel model1 = mesh_material_to_model(mesh1, material1);
>>>>>>> 5e7c086 (v1.02)
>>>>>>> 4df4acd (v1.02)
    //点光源
    Point_Light light(vec3(0.f, 1.f, 1.5f), vec3(0.f, 0.f, -1.f), vec3(8.f));
    MooModel model0 = get_light_model(light);
    //更新信息
    updated_paramters par;
    par.light_dir = &light.light_direction;
    par.light_pos = &light.light_position;
    par.light_radiance = &light.light_radiance;
    par.shadow_map = light.shadow_map;
    //渲染器
    MooRenderer renderer;
<<<<<<< HEAD
=======
<<<<<<< HEAD
>>>>>>> 4df4acd (v1.02)

    renderer.models.push_back(&model0);
    renderer.models.push_back(&model1);
    renderer.models.push_back(&model2);
    renderer.models.push_back(&model3);
<<<<<<< HEAD
=======
=======
    renderer.models.push_back(&model0);
    renderer.models.push_back(&model1);
>>>>>>> 5e7c086 (v1.02)
>>>>>>> 4df4acd (v1.02)
    renderer.point_lights.push_back(&light);

    FBO output(540, 1080);
    FBO output0(540, 540);
    FBO output1(540, 540);

    //神经网络
    nnet compressor, decompressor, rot_quat, quat_rot;
    nnet_evaluation compressor_evaluation, decompressor_evaluation, rot_quat_evaluation, quat_rot_evaluation;
    nnet_load(compressor, "../resources/compressor.bin");
    nnet_load(decompressor, "../resources/decompressor.bin");
    nnet_load(rot_quat, "../resources/rot_quat.bin");
    nnet_load(quat_rot, "../resources/quat_rot.bin");
    compressor_evaluation.resize(compressor);
    decompressor_evaluation.resize(decompressor);
    rot_quat_evaluation.resize(rot_quat);
    quat_rot_evaluation.resize(quat_rot);

<<<<<<< HEAD
=======
<<<<<<< HEAD
>>>>>>> 4df4acd (v1.02)
    // std::cout << compressor_evaluation.layers[0].size << ", " << compressor_evaluation.layers[compressor.weights.size()].size << std::endl;
    // std::cout << decompressor_evaluation.layers[0].size << ", " << decompressor_evaluation.layers[decompressor.weights.size()].size << std::endl;
    // std::cout << compressor_evaluation.layers.size() << ", " << decompressor_evaluation.layers.size() << std::endl;

    int key = 0;
    int t = 0;

    array1d<vec3> character_bone_anim_positions(motion.nbones());
    array1d<quat> character_bone_anim_rotations(motion.nbones());

<<<<<<< HEAD
=======
=======
    int key = 0;
    int t = 0;

>>>>>>> 5e7c086 (v1.02)
>>>>>>> 4df4acd (v1.02)
    array1d<vec3> robot_bone_anim_positions0(robot.nbones());
    array1d<quat> robot_bone_anim_rotations0(robot.nbones());
    array1d<vec3> robot_bone_anim_positions1(robot.nbones());
    array1d<quat> robot_bone_anim_rotations1(robot.nbones());

<<<<<<< HEAD
    array2d<float> rotations;
    array2d<float> positions;
    array2d<quat> quaternions;
=======
<<<<<<< HEAD
    array2d<float> rotations;
    array2d<float> positions;
    array2d<quat> quaternions;
=======
    array2d<float> rotations(14641, 4);
    array2d<float> positions(14641, 10);
    array2d<quat> quaternions(14641, 10);
>>>>>>> 5e7c086 (v1.02)
>>>>>>> 4df4acd (v1.02)
    array1d<quat> test;

    FILE* fr = fopen("../resources/rotations.bin", "rb");
    FILE* fp = fopen("../resources/positions.bin", "rb");
    FILE* fq = fopen("../resources/quaternions.bin", "rb");
    FILE* ft = fopen("../resources/test.bin", "rb");
    assert(fr != NULL && fp != NULL && fq != NULL && ft != NULL);

    array2d_read(rotations, fr);
    array2d_read(positions, fp);
    array2d_read(quaternions, fq);
    array1d_read(test, ft);

    fclose(fr);
    fclose(fp);
    fclose(fq);
    fclose(ft);

<<<<<<< HEAD
    array1d<float> vals(5000);
=======
<<<<<<< HEAD
    array1d<float> vals(5000);
=======
    array1d<float> vals(14641);
>>>>>>> 5e7c086 (v1.02)
>>>>>>> 4df4acd (v1.02)

    std::random_device dev;
    std::mt19937 rng(dev());
    std::uniform_real_distribution<float> dist(0.f, 1.f);

<<<<<<< HEAD
=======
<<<<<<< HEAD
>>>>>>> 4df4acd (v1.02)
    array1d<float> sh_points(5);
    array1d<float> el_points(5);
    array1d<float> wr_points(5);
    array1d<float> td(4);

    sh_points(0) = 105.f;
    sh_points(1) = 60.f;
    sh_points(2) = 15.f;
    sh_points(3) = 60.f;
    sh_points(4) = 105.f;

    el_points(0) = -80.f;
    el_points(1) = -100.f;
    el_points(2) = 0.f;
    el_points(3) = -70.f;
    el_points(4) = -80.f;

    wr_points(0) = 0.f;
    wr_points(1) = -60.f;
    wr_points(2) = 90.f;
    wr_points(3) = -10.f;
    wr_points(4) = 0.f;

    td(0) = 0.4f;
    td(1) = 0.1f;
    td(2) = 0.8f;
    td(3) = 0.3f;

    // array1d<float> sh_curve_points = LFPB(sh_points, td, 10000, 0.0166667f);
    // array1d<float> el_curve_points = LFPB(el_points, td, 10000, 0.0166667f);
    // array1d<float> wr_curve_points = LFPB(wr_points, td, 10000, 0.0166667f);

    // array1d<float> sh_curve_points = spine_curve(sh_points, 0.0166667f);
    // array1d<float> el_curve_points = spine_curve(el_points, 0.0166667f);
    // array1d<float> wr_curve_points = spine_curve(wr_points, 0.0166667f);

    vec3 target0 = vec3(0.f, 4.5f, 0.f);
    vec3 target1 = vec3(0.f, 2.0f, 0.f);

    while (key != 27)
    {
        if(t == 5000)
<<<<<<< HEAD
=======
=======
    vec3 target0 = vec3(0.f, 4.5f, 0.f);
    vec3 target1 = vec3(0.f, 2.0f, 0.f);

    // vec3 gamepadstick_left = vec3(-0.6f, 0.f, -0.9f);
    // vec3 gamepadstick_right = vec3(-1.1f, 0.f, -1.4f);

    // float lx = -0.12f;
    // float lz = -0.18f;
    // float rx = -0.22f;
    // float rz = -0.28f;

    int blend = 0;

    while (key != 27 && t < 14641)
    {
        if(t == 14641)
>>>>>>> 5e7c086 (v1.02)
>>>>>>> 4df4acd (v1.02)
        {
            t = 0;
        }

        output0.set(vec3(100.f, 200.f, 100.f), 100.f);
        output1.set(vec3(100.f, 200.f, 100.f), 100.f);

        BeginDrawing();
        ClearBackground(RAYWHITE);
        vec3 gamepadstick_left = gamepad_get_stick(GAMEPAD_STICK_LEFT);
        vec3 gamepadstick_right = gamepad_get_stick(GAMEPAD_STICK_RIGHT);

<<<<<<< HEAD
=======
<<<<<<< HEAD
>>>>>>> 4df4acd (v1.02)
        // output0.set(vec3(0.f, 0.f, 0.f), 100.f);
        // output1.set(vec3(0.f, 0.f, 0.f), 100.f);

        // camera.position.x = sin(deg_to_rad(t));
        // camera.position.y = sin(deg_to_rad(2 * t + 45));
        // camera.position.z = 2.f + 0.5f * sin(deg_to_rad(t));

        // renderer.models[2]->transform = mat4(1.5f);

        renderer.models[3]->transform = mat4(eye3(), vec3(-24.f, 0.f, 0.f)) * 
                                        mat4(5.f);

        batch_forward_kinematics_full(motion, t, character_bone_anim_positions, character_bone_anim_rotations);

        deform_character_anim_mesh(character, character_bone_anim_positions, character_bone_anim_rotations, mesh1);

        // light.light_position = character_bone_anim_positions(0) + vec3(0.5 * sin(deg_to_rad(t)), 1.f + 0.5 * sin(deg_to_rad(2 * t)), 1.f * sin(deg_to_rad(3 * t)));
        // light.light_direction = vec3(0.f, 1.2f, 0.f) - light.light_position;
        light.light_position = vec3(5.f, 5.f, 0.f);
        renderer.models[0]->transform = mat4(eye3(), renderer.point_lights[0]->light_position) * 
                                        mat4(0.01f);
        // renderer.models[1]->transform = mat4(2.f);

        // renderer.models[2]->transform = mat4(mat3(vec3(0.5f, 0.f, 0.f), vec3(0.f, 1.f, 0.f), vec3(0.f, 0.f, 0.5f)), vec3(0.f, 0.f, 0.f));

        // renderer.models[2]->transform = mat4(Rodrigues(2 * t, vec3(0.f, -1.f, 0.f)), vec3());
        // renderer.models[2]->transform = mat4(eye3(), vec3(0.f, 0.f, 0.f));

        // gamepadstick_left.x = 2.f * dist(rng) - 1.f;
        // gamepadstick_left.z = 2.f * dist(rng) - 1.f;
        // gamepadstick_right.x = gamepadstick_left.z;
        // gamepadstick_right.z = gamepadstick_left.z;
        
        // slice1d_set(
        //     rotations(t), 
        //     std::vector<float>{
        //         PI / 4.f * gamepadstick_left.x, 
        //         0.8f * gamepadstick_left.z, 
        //         1.0f * gamepadstick_right.x, 
        //         0.9f * gamepadstick_right.z});
<<<<<<< HEAD
=======
=======
        // if(t % 11 == 0)
        // {
        //     lx = -lx;
        // }
        // else if(t % 1 == 0)
        // {
        //     gamepadstick_left.x = gamepadstick_left.x + lx;
            
        // }

        // if(t % 121 == 0)
        // {
        //     lz = -lz;
        // }
        // else if(t % 11 == 0)
        // {
        //     gamepadstick_left.z = gamepadstick_left.z + lz;
        // }

        // if(t % 1331 == 0)
        // {
        //     rx = -rx;
        // }
        // else if(t % 121 == 0)
        // {
        //     gamepadstick_right.x = gamepadstick_right.x + rx;
        // }

        // if(t % 14641 == 0)
        // {
        //     rz = -rz;
        // }
        // else if(t % 1331 == 0)
        // {
        //     gamepadstick_right.z = gamepadstick_right.z + rz;
        // }

        light.light_position = vec3(5.f, 5.f, 0.f);
        renderer.models[0]->transform = mat4(eye3(), renderer.point_lights[0]->light_position) * 
                                        mat4(0.01f);

        // target0.x = 0.0f * sin(deg_to_rad(1.1f * t));
        target0.y = target0.y - 0.01f * gamepadstick_left.z;
        target0.z = target0.z - 0.01f * gamepadstick_left.x;
        // target1.x = 0.0f * cos(deg_to_rad(1.4f * t));
        target1.y = target1.y - 0.01f * gamepadstick_right.z;
        target1.z = target1.z - 0.01f * gamepadstick_right.x;
        // FABRIK_two_end(robot.bone_local_positions, robot.bone_local_rotations, target0, target1, 9, 4);
        FABRIK_two_end_constraints(robot.bone_local_positions, robot.bone_local_rotations, target0, target1, 9, 1, 45);
        // FABRIK_one_end(robot.bone_local_positions, robot.bone_local_rotations, target0, 9);
        // FABRIK_one_end_constraints(robot.bone_local_positions, robot.bone_local_rotations, target0, 9, 45);

        if(gamepadstick_left.x > 0.5)
        {
            blend = blend + 1;
        }
        else if(gamepadstick_left.x < -0.5)
        {
            blend = blend - 1;
        }

        // for(int i = 1; i < robot.nbones(); i++)
        // {
        //     robot.bone_local_rotations(i) = quat((0.64 + i * 0.06) * blend, vec3(1.f, 0.f, 0.f));
        // }

        // robot.bone_local_rotations(2) = quat((0.8) * blend, vec3(1.f, 0.f, 0.f));
        // robot.bone_local_rotations(5) = quat((-0.8) * blend, vec3(1.f, 0.f, 0.f));
        // robot.bone_local_rotations(8) = quat((0.8) * blend, vec3(1.f, 0.f, 0.f));

        slice1d_set(
            rotations(t), 
            std::vector<float>{
                0.6f * gamepadstick_left.x, 
                0.9f * gamepadstick_left.z, 
                1.1f * gamepadstick_right.x, 
                1.4f * gamepadstick_right.z});
>>>>>>> 5e7c086 (v1.02)
>>>>>>> 4df4acd (v1.02)

        // slice1d_set(
        //     rotations(t), 
        //     std::vector<float>{
        //         PI / 4.f * sin(deg_to_rad(0.63f * t)), 
        //         1.0f * sin(deg_to_rad(2.6f * t)), 
        //         0.9f * sin(deg_to_rad(1.5f * t + 45)), 
        //         0.5f * cos(deg_to_rad(0.9f * t))});

        // slice1d_set(
        //     quaternions(t), 
        //     std::vector<quat>{
        //         quat(rad_to_deg(0.8f * gamepadstick_right.x), vec3(0.f, 1.f, 0.f)), 
        //         quat(0.f, vec3(1.f, 0.f, 0.f)), 
        //         quat(sh_curve_points(t), vec3(1.f, 0.f, 0.f)), 
        //         quat(0.f, vec3(1.f, 0.f, 0.f)), 
        //         quat(el_curve_points(t), vec3(1.f, 0.f, 0.f)), 
        //         quat(0.f, vec3(1.f, 0.f, 0.f)), 
        //         quat(wr_curve_points(t), vec3(1.f, 0.f, 0.f))});

<<<<<<< HEAD
=======
<<<<<<< HEAD
>>>>>>> 4df4acd (v1.02)
        array2d_set_by_rows(quaternions, test, t);

        nnet_evaluate(
            quaternions(t),
            rotations(t),
            quat_rot_evaluation,
            quat_rot);

        robot_evaluate(
            rotations(t),
            positions(t));

        // nnet_evaluate(
        //     rotations(t),
        //     quaternions(t),
        //     rot_quat_evaluation,
        //     rot_quat);

        // robot_evaluate(
        //     rotations(t),
        //     positions(t));

        // target0 = vec3(1.f * sin(deg_to_rad(5.f * t)), 2.5f - 1.5f * sin(deg_to_rad(1.5f * t)), - 5.f * (-1.f + 2.f / 5000.f * t));
        // FABRIK_one_end(robot.bone_local_positions, robot.bone_local_rotations, target0, 7);

        // target0 = vec3(0.75f * sin(deg_to_rad(1.1f * t)), 3.5f - 3.f * gamepadstick_left.z, - 7.5f * gamepadstick_left.x);
        // target1 = vec3(0.5f * cos(deg_to_rad(1.4f * t)), 2.0f - 1.5f * gamepadstick_right.z, - 5.f * gamepadstick_right.x);
        // target0 = vec3(0.f, (3.5f + 1.f * sin(deg_to_rad(1.1f * t))) * sin(PI / 12.f + PI / 6000.f * t), (3.5f + 1.f * sin(deg_to_rad(1.1f * t))) * cos(PI / 12.f + PI / 6000.f * t));
        // target1 = vec3(0.f, 2.f, 0.75f * cos(deg_to_rad(2.3f * t)));
        // target0.x = 0.75f * sin(deg_to_rad(1.1f * t));
        // target0.y = target0.y - 0.01f * gamepadstick_left.z;
        // target0.z = target0.z - 0.01f * gamepadstick_left.x;
        // target1.x = 0.5f * cos(deg_to_rad(1.4f * t));
        // target1.y = target1.y - 0.01f * gamepadstick_right.z;
        // target1.z = target1.z - 0.01f * gamepadstick_right.x;
        // FABRIK_two_end(robot.bone_local_positions, robot.bone_local_rotations, target0, target1, 9, 4);
        // FABRIK_two_end_constraints(robot.bone_local_positions, robot.bone_local_rotations, target0, target1, 9, 4, 45);
        // FABRIK_one_end(robot.bone_local_positions, robot.bone_local_rotations, target0, 9);
        // FABRIK_one_end_constraints(robot.bone_local_positions, robot.bone_local_rotations, target0, 9, 45);

        // robot_forward_kinematics_full(robot, robot_bone_anim_positions0, robot_bone_anim_rotations0);
        robot_forward_kinematics_positions(robot, robot_bone_anim_positions0, robot_bone_anim_rotations0, positions(t));
        // robot_forward_kinematics_quaternions(robot, robot_bone_anim_positions0, robot_bone_anim_rotations0, quaternions(t));
        deform_robot_anim_mesh(robot, robot_bone_anim_positions0, robot_bone_anim_rotations0, mesh2);

        // camera.set_pos(vec3(2.f, 3.f, 0.f));
        // camera.set_pos(vec3(4.f, 2.f, -0.5f));
        camera.set_pos(vec3(8.f, 2.f, 0.5f));
        camera.set_view(vec3(-1.f, 0.f, 0.f));
        camera.update_orientation(vec3(0.f, 1.f, 0.f));

        // camera.set_pos(vec3(2.5f, 2.f, 0.8f));
        // camera.set_view(vec3(-1.f, 0.f, 0.f));
        // camera.update_orientation(vec3(0.f, 1.f, 0.f));

        // controller.pos_pid_control(1.f, 0.01f, 0.1f, 200.f, 1.f / 60.f, character_bone_anim_positions(0) + character_bone_anim_rotations(0) * vec3(0.f, 1.2f, -2.f));
        // controller.dir_pid_control(0.7, 0.01f, 0.5f, 200.f, 1.f / 60.f, character_bone_anim_rotations(0) * vec3(0.f, 0.f, 1.f));
        // camera.update_orientation(vec3(0.f, 1.f, 0.f));

        // vec3 yxz = quat_to_euler_YXZ(character_bone_anim_rotations(0));
        // mat3 R = Rodrigues(yxz.x, vec3(0.f, 1.f, 0.f));
        // camera.set_pos(character_bone_anim_positions(0) + character_bone_anim_rotations(0) * vec3(0.f, 1.2f, -2.f));
        // camera.set_view((character_bone_anim_rotations(0) * vec3(0.f, 0.f, 1.f)));
        // camera.update_orientation(vec3(0.f, 1.f, 0.f));
        // camera.set_view(R * vec3(0.f, 0.f, -1.f), vec3(0.f, 1.f, 0.f));

        draw(renderer.models[0], camera, &output0, &par, true);
        // draw(renderer.models[1], camera, &output0, &par, true);
        draw(renderer.models[2], camera, &output0, &par, true);
        // draw(renderer.models[3], camera, &output0, &par, true);
        // draw_point(target0, camera, &output0, vec3(255.f, 0.f, 0.f));
        // draw_point(target1, camera, &output0, vec3(0.f, 0.f, 255.f));
        for(int i = 0; i < 9; i++)
        {
            draw_point(robot_bone_anim_positions0(i), camera, &output0, vec3(0.f, 255.f, 0.f));
            draw_line(robot_bone_anim_positions0(i), robot_bone_anim_positions0(i + 1), camera, &output0, (0.f, 0.f, 0.f));
        }
        draw_point(robot_bone_anim_positions0(9), camera, &output0, vec3(0.f, 255.f, 0.f));

        // renderer.models[1]->transform = mat4(1.f);

        // nnet_evaluate(
        //     rotations(t),
        //     quaternions(t),
        //     rot_quat_evaluation,
        //     rot_quat);

        // array2d_set_by_rows(quaternions, robot.bone_local_rotations, t);
<<<<<<< HEAD
=======
=======
        // array2d_set_by_rows(quaternions, test, t);
>>>>>>> 5e7c086 (v1.02)
>>>>>>> 4df4acd (v1.02)

        // nnet_evaluate(
        //     quaternions(t),
        //     rotations(t),
        //     quat_rot_evaluation,
        //     quat_rot);

        // robot_evaluate(
        //     rotations(t),
        //     positions(t));

<<<<<<< HEAD
=======
<<<<<<< HEAD
>>>>>>> 4df4acd (v1.02)
        // robot_forward_kinematics_full(robot, robot_bone_anim_positions1, robot_bone_anim_rotations1);
        robot_forward_kinematics_positions(robot, robot_bone_anim_positions1, robot_bone_anim_rotations1, positions(t));
        // robot_forward_kinematics_quaternions(robot, robot_bone_anim_positions1, robot_bone_anim_rotations1, quaternions(t));
        deform_robot_anim_mesh(robot, robot_bone_anim_positions1, robot_bone_anim_rotations1, mesh2);

        // camera.set_pos(vec3(2.f, 3.f, -1.8f));
        // camera.set_pos(vec3(4.f, 2.f, -2.5f));
        camera.set_pos(vec3(8.f, 2.f, -0.5f));
        camera.set_view(vec3(-1.f, 0.f, 0.f));
        camera.update_orientation(vec3(0.f, 1.f, 0.f));

        // camera.set_pos(vec3(2.5f, 2.f, -0.2f));
        // camera.set_view(vec3(-1.f, 0.f, 0.f));
        // camera.update_orientation(vec3(0.f, 1.f, 0.f));

        draw(renderer.models[0], camera, &output1, &par, true);
        // draw(renderer.models[1], camera, &output1, &par, true);
        draw(renderer.models[2], camera, &output1, &par, true);
        // draw(renderer.models[3], camera, &output1, &par, true);
<<<<<<< HEAD
=======
=======
        // nnet_evaluate(
        //     rotations(t),
        //     quaternions(t),
        //     rot_quat_evaluation,
        //     rot_quat);

        robot_evaluate(
            rotations(t),
            positions(t));

        // robot.bone_local_rotations(1) = quat(positions(t, 1), vec3(1.f, 0.f, 0.f));
        // robot.bone_local_rotations(2) = quat(positions(t, 2), vec3(1.f, 0.f, 0.f));
        // robot.bone_local_rotations(3) = quat(positions(t, 3), vec3(1.f, 0.f, 0.f));
        // robot.bone_local_rotations(4) = quat(positions(t, 4), vec3(1.f, 0.f, 0.f));
        // robot.bone_local_rotations(5) = quat(positions(t, 5), vec3(1.f, 0.f, 0.f));
        // robot.bone_local_rotations(6) = quat(positions(t, 6), vec3(1.f, 0.f, 0.f));
        // robot.bone_local_rotations(7) = quat(positions(t, 7), vec3(1.f, 0.f, 0.f));
        // robot.bone_local_rotations(8) = quat(positions(t, 8), vec3(1.f, 0.f, 0.f));

        robot_forward_kinematics_full(robot, robot_bone_anim_positions0, robot_bone_anim_rotations0);
        // robot_forward_kinematics_positions(robot, robot_bone_anim_positions0, robot_bone_anim_rotations0, positions(t));
        // robot_forward_kinematics_quaternions(robot, robot_bone_anim_positions0, robot_bone_anim_rotations0, quaternions(t));
        deform_robot_anim_mesh(robot, robot_bone_anim_positions0, robot_bone_anim_rotations0, mesh1);

        // camera.set_pos(vec3(2.f, 3.f, 0.f));
        // camera.set_pos(vec3(4.f, 2.f, -0.5f));
        camera.set_pos(vec3(8.f, 2.f, 0.f));
        camera.set_view(vec3(-1.f, 0.f, 0.f));
        camera.update_orientation(vec3(0.f, 1.f, 0.f));

        draw(renderer.models[0], camera, &output0, &par, true);
        draw(renderer.models[1], camera, &output0, &par, true);

        draw_point(target0, camera, &output0, vec3(255.f, 0.f, 0.f));
        draw_point(target1, camera, &output0, vec3(0.f, 0.f, 255.f));
        for(int i = 0; i < 9; i++)
        {
            draw_point(robot_bone_anim_positions0(i), camera, &output0, vec3(0.f, 255.f, 0.f));
            draw_line(robot_bone_anim_positions0(i), robot_bone_anim_positions0(i + 1), camera, &output0, (0.f, 0.f, 0.f));
        }
        draw_point(robot_bone_anim_positions0(9), camera, &output0, vec3(0.f, 255.f, 0.f));

        // nnet_evaluate(
        //     rotations(t),
        //     quaternions(t),
        //     rot_quat_evaluation,
        //     rot_quat);

        array2d_set_by_rows(quaternions, robot.bone_local_rotations, t);

        nnet_evaluate(
            quaternions(t),
            rotations(t),
            quat_rot_evaluation,
            quat_rot);

        robot_evaluate(
            rotations(t),
            positions(t));

        // robot_forward_kinematics_full(robot, robot_bone_anim_positions1, robot_bone_anim_rotations1);
        robot_forward_kinematics_positions(robot, robot_bone_anim_positions1, robot_bone_anim_rotations1, positions(t));
        // robot_forward_kinematics_quaternions(robot, robot_bone_anim_positions1, robot_bone_anim_rotations1, quaternions(t));
        deform_robot_anim_mesh(robot, robot_bone_anim_positions1, robot_bone_anim_rotations1, mesh1);

        // camera.set_pos(vec3(2.f, 3.f, -1.8f));
        // camera.set_pos(vec3(4.f, 2.f, -2.5f));
        camera.set_pos(vec3(8.f, 2.f, -0.f));
        camera.set_view(vec3(-1.f, 0.f, 0.f));
        camera.update_orientation(vec3(0.f, 1.f, 0.f));

        draw(renderer.models[0], camera, &output1, &par, true);
        draw(renderer.models[1], camera, &output1, &par, true);

>>>>>>> 5e7c086 (v1.02)
>>>>>>> 4df4acd (v1.02)
        // draw_point(target0, camera, &output1, vec3(255.f, 0.f, 0.f));
        // draw_point(target1, camera, &output1, vec3(0.f, 0.f, 255.f));
        for(int i = 0; i < 9; i++)
        {
<<<<<<< HEAD
=======
<<<<<<< HEAD
>>>>>>> 4df4acd (v1.02)
            draw_point(robot_bone_anim_positions1(i), camera, &output1, vec3(0.f, 255.f, 0.f));
            draw_line(robot_bone_anim_positions1(i), robot_bone_anim_positions1(i + 1), camera, &output1, (0.f, 0.f, 0.f));
        }
        draw_point(robot_bone_anim_positions1(9), camera, &output1, vec3(0.f, 255.f, 0.f));

        // cv::imshow("left", fbo_to_img(&output0));
        // cv::imshow("right", fbo_to_img(&output1));
        output = contance_two_fbos(&output0, &output1, 0.5f, 0.5f);
        cv::imshow("img", fbo_to_img(&output));
        key = cv::waitKey(1);

        // char left_name[50];
        // char right_name[50];
        // sprintf(left_name, "../../Shape_Feature_Extraction/resources/img/zleft%d.png", t);
        // sprintf(right_name, "../../Shape_Feature_Extraction/resources/img/zright%d.png", t);
<<<<<<< HEAD
=======
=======
            draw_point(robot_bone_anim_positions1(i), camera, &output1, vec3(255.f, 0.f, 0.f));
            draw_line(robot_bone_anim_positions1(i), robot_bone_anim_positions1(i + 1), camera, &output1, vec3(255.f, 0.f, 0.f));
        }
        draw_point(robot_bone_anim_positions1(9), camera, &output1, vec3(255.f, 0.f, 0.f));

        for(int i = 0; i < 9; i++)
        {
            draw_point(robot_bone_anim_positions0(i), camera, &output1, vec3(0.f, 0.f, 255.f));
            draw_line(robot_bone_anim_positions0(i), robot_bone_anim_positions0(i + 1), camera, &output1, vec3(0.f, 0.f, 255.f));
        }
        draw_point(robot_bone_anim_positions0(9), camera, &output1, vec3(0.f, 0.f, 255.f));

        cv::imshow("left", fbo_to_img(&output0));
        cv::imshow("right", fbo_to_img(&output1));
        // output = concatenate_two_fbos(&output0, &output1, 0.5f, 0.5f);
        // cv::imshow("img", fbo_to_img(&output));
        key = cv::waitKey(1);

        // char left_name[100];
        // char right_name[100];
        // sprintf(left_name, "../../Vision_Based_Shape_Reconstruction/resources/img/zleft%d.png", t);
        // sprintf(right_name, "../../Vision_Based_Shape_Reconstruction/resources/img/zright%d.png", t);
>>>>>>> 5e7c086 (v1.02)
>>>>>>> 4df4acd (v1.02)
        // cv::imwrite(left_name, fbo_to_img(&output0));
        // cv::imwrite(right_name, fbo_to_img(&output1));

        // vals(t) = compute_val(robot_bone_anim_positions0, robot_bone_anim_positions1);

        // std::cout << vals(t) << std::endl;
<<<<<<< HEAD

=======
<<<<<<< HEAD

=======
        // std::cout << blend << std::endl;
>>>>>>> 5e7c086 (v1.02)
>>>>>>> 4df4acd (v1.02)
        std::cout << t << std::endl;
        t++;
        // print(character_bone_anim_positions(0));
        EndDrawing();
    }

    // std::ofstream outfile;
    // outfile.open("../resources/val_quat.txt");

<<<<<<< HEAD
    // for(int i = 0; i < 5000; i++)
=======
<<<<<<< HEAD
    // for(int i = 0; i < 5000; i++)
=======
    // for(int i = 0; i < 14641; i++)
>>>>>>> 5e7c086 (v1.02)
>>>>>>> 4df4acd (v1.02)
    // {
    //     outfile << vals(i) << "\n";
    // }

    // outfile.close();
    
    return 0;
}

