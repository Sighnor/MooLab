extern "C"
{
#include "raylib.h"
#include "raymath.h"
//#define RAYGUI_IMPLEMENTATION
//#include "raygui.h"
}

#include "character.hpp"
#include "controller.hpp"
#include "curve.hpp"
#include "database.hpp"
#include "ik.hpp"
#include "motion.hpp"
#include "nnet.hpp"
#include "renderer.hpp"
#include "robot.hpp"

enum
{
    GAMEPAD_PLAYER = 0,
};

enum
{
    GAMEPAD_STICK_LEFT,
    GAMEPAD_STICK_RIGHT,
};

vec3 gamepad_get_stick(int stick, const float deadzone = 0.2f)
{
    float gamepadx = GetGamepadAxisMovement(GAMEPAD_PLAYER, stick == GAMEPAD_STICK_LEFT ? GAMEPAD_AXIS_LEFT_X : GAMEPAD_AXIS_RIGHT_X);
    float gamepady = GetGamepadAxisMovement(GAMEPAD_PLAYER, stick == GAMEPAD_STICK_LEFT ? GAMEPAD_AXIS_LEFT_Y : GAMEPAD_AXIS_RIGHT_Y);
    float gamepadmag = sqrtf(gamepadx*gamepadx + gamepady*gamepady);
    
    if (gamepadmag > deadzone)
    {
        float gamepaddirx = gamepadx / gamepadmag;
        float gamepaddiry = gamepady / gamepadmag;
        float gamepadclippedmag = gamepadmag > 1.0f ? 1.0f : gamepadmag*gamepadmag;
        gamepadx = gamepaddirx * gamepadclippedmag;
        gamepady = gamepaddiry * gamepadclippedmag;
    }
    else
    {
        gamepadx = 0.0f;
        gamepady = 0.0f;
    }
    
    return vec3(gamepadx, 0.0f, gamepady);
}

int main(int argc, char** argv)
{
    InitWindow(720, 720, "raylib [background]");
    SetTargetFPS(60);
    
    // float frequency;
    // float halflife;
    // frequency = GuiSliderBar((Rectangle){ 100, 20, 120, 20 }, "frequency", TextFormat("%5.3f", frequency), frequency, 0.0f, 3.0f);
    // halflife = GuiSliderBar((Rectangle){ 100, 45, 120, 20 }, "halflife", TextFormat("%5.3f", halflife), halflife, 0.0f, 1.0f);

    //相机
    MooCamera camera(1, 0.1f, 0.1f, 0.05f, 50.f, vec3(0.f, 1.2f, - 3.f), mat3());
    camera.set_view(vec3(0.f, 0.f, 1.f));
    camera.update_orientation(vec3(0.f, 1.f, 0.f));
    //机器人
    Robot robot;
    robot_load(robot, "../resources/robot.bin");
    // robot = create_robot(0.4f, 5.f, 18, 50, 10, 0.8f);
    // robot_save(robot, "../resources/robot.bin");
    //对角色数据的拷贝
    MooMesh mesh1 = make_robot_rest_mesh(robot);
    //材质
    MooMaterial material1(PBR);
    material1.roughness = 0.75f;
    material1.tex = img_to_tex("../resources/texture.png");
    material1.BRDFLut = img_to_tex("../resources/BRDFLut.png");
    material1.EavgLut = img_to_tex("../resources/EavgLut.png");
    //model存储mesh的拷贝，但由于mesh本身存储的是地址，实际上仍为mesh地址上的数据
    MooModel model1 = mesh_material_to_model(mesh1, material1);
    //点光源
    Point_Light light(vec3(0.f, 1.f, 1.5f), vec3(0.f, 0.f, -1.f), vec3(8.f));
    MooModel model0 = get_light_model(light);
    //更新信息
    updated_paramters par;
    par.light_dir = &light.light_direction;
    par.light_pos = &light.light_position;
    par.light_radiance = &light.light_radiance;
    par.shadow_map = light.shadow_map;
    //渲染器
    MooRenderer renderer;
    renderer.models.push_back(&model0);
    renderer.models.push_back(&model1);
    renderer.point_lights.push_back(&light);

    FBO output(540, 1080);
    FBO output0(540, 540);
    FBO output1(540, 540);

    //神经网络
    nnet compressor, decompressor, rot_quat, quat_rot;
    nnet_evaluation compressor_evaluation, decompressor_evaluation, rot_quat_evaluation, quat_rot_evaluation;
    nnet_load(compressor, "../resources/compressor.bin");
    nnet_load(decompressor, "../resources/decompressor.bin");
    nnet_load(rot_quat, "../resources/rot_quat.bin");
    nnet_load(quat_rot, "../resources/quat_rot.bin");
    compressor_evaluation.resize(compressor);
    decompressor_evaluation.resize(decompressor);
    rot_quat_evaluation.resize(rot_quat);
    quat_rot_evaluation.resize(quat_rot);

    int key = 0;
    int t = 0;

    array1d<vec3> robot_bone_anim_positions0(robot.nbones());
    array1d<quat> robot_bone_anim_rotations0(robot.nbones());
    array1d<vec3> robot_bone_anim_positions1(robot.nbones());
    array1d<quat> robot_bone_anim_rotations1(robot.nbones());

    array2d<float> rotations(14641, 4);
    array2d<float> positions(14641, 10);
    array2d<quat> quaternions(14641, 10);
    array1d<quat> test;

    FILE* fr = fopen("../resources/rotations.bin", "rb");
    FILE* fp = fopen("../resources/positions.bin", "rb");
    FILE* fq = fopen("../resources/quaternions.bin", "rb");
    FILE* ft = fopen("../resources/test.bin", "rb");
    assert(fr != NULL && fp != NULL && fq != NULL && ft != NULL);

    array2d_read(rotations, fr);
    array2d_read(positions, fp);
    array2d_read(quaternions, fq);
    array1d_read(test, ft);

    fclose(fr);
    fclose(fp);
    fclose(fq);
    fclose(ft);

    array1d<float> vals(14641);

    std::random_device dev;
    std::mt19937 rng(dev());
    std::uniform_real_distribution<float> dist(0.f, 1.f);

    vec3 target0 = vec3(0.f, 4.5f, 0.f);
    vec3 target1 = vec3(0.f, 2.0f, 0.f);

    // vec3 gamepadstick_left = vec3(-0.6f, 0.f, -0.9f);
    // vec3 gamepadstick_right = vec3(-1.1f, 0.f, -1.4f);

    // float lx = -0.12f;
    // float lz = -0.18f;
    // float rx = -0.22f;
    // float rz = -0.28f;

    int blend = 0;

    while (key != 27 && t < 14641)
    {
        if(t == 14641)
        {
            t = 0;
        }

        output0.set(vec3(100.f, 200.f, 100.f), 100.f);
        output1.set(vec3(100.f, 200.f, 100.f), 100.f);

        BeginDrawing();
        ClearBackground(RAYWHITE);
        vec3 gamepadstick_left = gamepad_get_stick(GAMEPAD_STICK_LEFT);
        vec3 gamepadstick_right = gamepad_get_stick(GAMEPAD_STICK_RIGHT);

        // if(t % 11 == 0)
        // {
        //     lx = -lx;
        // }
        // else if(t % 1 == 0)
        // {
        //     gamepadstick_left.x = gamepadstick_left.x + lx;
            
        // }

        // if(t % 121 == 0)
        // {
        //     lz = -lz;
        // }
        // else if(t % 11 == 0)
        // {
        //     gamepadstick_left.z = gamepadstick_left.z + lz;
        // }

        // if(t % 1331 == 0)
        // {
        //     rx = -rx;
        // }
        // else if(t % 121 == 0)
        // {
        //     gamepadstick_right.x = gamepadstick_right.x + rx;
        // }

        // if(t % 14641 == 0)
        // {
        //     rz = -rz;
        // }
        // else if(t % 1331 == 0)
        // {
        //     gamepadstick_right.z = gamepadstick_right.z + rz;
        // }

        light.light_position = vec3(5.f, 5.f, 0.f);
        renderer.models[0]->transform = mat4(eye3(), renderer.point_lights[0]->light_position) * 
                                        mat4(0.01f);

        // target0.x = 0.0f * sin(deg_to_rad(1.1f * t));
        target0.y = target0.y - 0.01f * gamepadstick_left.z;
        target0.z = target0.z - 0.01f * gamepadstick_left.x;
        // target1.x = 0.0f * cos(deg_to_rad(1.4f * t));
        target1.y = target1.y - 0.01f * gamepadstick_right.z;
        target1.z = target1.z - 0.01f * gamepadstick_right.x;
        // FABRIK_two_end(robot.bone_local_positions, robot.bone_local_rotations, target0, target1, 9, 4);
        FABRIK_two_end_constraints(robot.bone_local_positions, robot.bone_local_rotations, target0, target1, 9, 1, 45);
        // FABRIK_one_end(robot.bone_local_positions, robot.bone_local_rotations, target0, 9);
        // FABRIK_one_end_constraints(robot.bone_local_positions, robot.bone_local_rotations, target0, 9, 45);

        if(gamepadstick_left.x > 0.5)
        {
            blend = blend + 1;
        }
        else if(gamepadstick_left.x < -0.5)
        {
            blend = blend - 1;
        }

        // for(int i = 1; i < robot.nbones(); i++)
        // {
        //     robot.bone_local_rotations(i) = quat((0.64 + i * 0.06) * blend, vec3(1.f, 0.f, 0.f));
        // }

        // robot.bone_local_rotations(2) = quat((0.8) * blend, vec3(1.f, 0.f, 0.f));
        // robot.bone_local_rotations(5) = quat((-0.8) * blend, vec3(1.f, 0.f, 0.f));
        // robot.bone_local_rotations(8) = quat((0.8) * blend, vec3(1.f, 0.f, 0.f));

        slice1d_set(
            rotations(t), 
            std::vector<float>{
                0.6f * gamepadstick_left.x, 
                0.9f * gamepadstick_left.z, 
                1.1f * gamepadstick_right.x, 
                1.4f * gamepadstick_right.z});

        // slice1d_set(
        //     rotations(t), 
        //     std::vector<float>{
        //         PI / 4.f * sin(deg_to_rad(0.63f * t)), 
        //         1.0f * sin(deg_to_rad(2.6f * t)), 
        //         0.9f * sin(deg_to_rad(1.5f * t + 45)), 
        //         0.5f * cos(deg_to_rad(0.9f * t))});

        // slice1d_set(
        //     quaternions(t), 
        //     std::vector<quat>{
        //         quat(rad_to_deg(0.8f * gamepadstick_right.x), vec3(0.f, 1.f, 0.f)), 
        //         quat(0.f, vec3(1.f, 0.f, 0.f)), 
        //         quat(sh_curve_points(t), vec3(1.f, 0.f, 0.f)), 
        //         quat(0.f, vec3(1.f, 0.f, 0.f)), 
        //         quat(el_curve_points(t), vec3(1.f, 0.f, 0.f)), 
        //         quat(0.f, vec3(1.f, 0.f, 0.f)), 
        //         quat(wr_curve_points(t), vec3(1.f, 0.f, 0.f))});

        // array2d_set_by_rows(quaternions, test, t);

        // nnet_evaluate(
        //     quaternions(t),
        //     rotations(t),
        //     quat_rot_evaluation,
        //     quat_rot);

        // robot_evaluate(
        //     rotations(t),
        //     positions(t));

        // nnet_evaluate(
        //     rotations(t),
        //     quaternions(t),
        //     rot_quat_evaluation,
        //     rot_quat);

        robot_evaluate(
            rotations(t),
            positions(t));

        // robot.bone_local_rotations(1) = quat(positions(t, 1), vec3(1.f, 0.f, 0.f));
        // robot.bone_local_rotations(2) = quat(positions(t, 2), vec3(1.f, 0.f, 0.f));
        // robot.bone_local_rotations(3) = quat(positions(t, 3), vec3(1.f, 0.f, 0.f));
        // robot.bone_local_rotations(4) = quat(positions(t, 4), vec3(1.f, 0.f, 0.f));
        // robot.bone_local_rotations(5) = quat(positions(t, 5), vec3(1.f, 0.f, 0.f));
        // robot.bone_local_rotations(6) = quat(positions(t, 6), vec3(1.f, 0.f, 0.f));
        // robot.bone_local_rotations(7) = quat(positions(t, 7), vec3(1.f, 0.f, 0.f));
        // robot.bone_local_rotations(8) = quat(positions(t, 8), vec3(1.f, 0.f, 0.f));

        robot_forward_kinematics_full(robot, robot_bone_anim_positions0, robot_bone_anim_rotations0);
        // robot_forward_kinematics_positions(robot, robot_bone_anim_positions0, robot_bone_anim_rotations0, positions(t));
        // robot_forward_kinematics_quaternions(robot, robot_bone_anim_positions0, robot_bone_anim_rotations0, quaternions(t));
        deform_robot_anim_mesh(robot, robot_bone_anim_positions0, robot_bone_anim_rotations0, mesh1);

        // camera.set_pos(vec3(2.f, 3.f, 0.f));
        // camera.set_pos(vec3(4.f, 2.f, -0.5f));
        camera.set_pos(vec3(8.f, 2.f, 0.f));
        camera.set_view(vec3(-1.f, 0.f, 0.f));
        camera.update_orientation(vec3(0.f, 1.f, 0.f));

        draw(renderer.models[0], camera, &output0, &par, true);
        draw(renderer.models[1], camera, &output0, &par, true);

        draw_point(target0, camera, &output0, vec3(255.f, 0.f, 0.f));
        draw_point(target1, camera, &output0, vec3(0.f, 0.f, 255.f));
        for(int i = 0; i < 9; i++)
        {
            draw_point(robot_bone_anim_positions0(i), camera, &output0, vec3(0.f, 255.f, 0.f));
            draw_line(robot_bone_anim_positions0(i), robot_bone_anim_positions0(i + 1), camera, &output0, (0.f, 0.f, 0.f));
        }
        draw_point(robot_bone_anim_positions0(9), camera, &output0, vec3(0.f, 255.f, 0.f));

        // nnet_evaluate(
        //     rotations(t),
        //     quaternions(t),
        //     rot_quat_evaluation,
        //     rot_quat);

        array2d_set_by_rows(quaternions, robot.bone_local_rotations, t);

        nnet_evaluate(
            quaternions(t),
            rotations(t),
            quat_rot_evaluation,
            quat_rot);

        robot_evaluate(
            rotations(t),
            positions(t));

        // robot_forward_kinematics_full(robot, robot_bone_anim_positions1, robot_bone_anim_rotations1);
        robot_forward_kinematics_positions(robot, robot_bone_anim_positions1, robot_bone_anim_rotations1, positions(t));
        // robot_forward_kinematics_quaternions(robot, robot_bone_anim_positions1, robot_bone_anim_rotations1, quaternions(t));
        deform_robot_anim_mesh(robot, robot_bone_anim_positions1, robot_bone_anim_rotations1, mesh1);

        // camera.set_pos(vec3(2.f, 3.f, -1.8f));
        // camera.set_pos(vec3(4.f, 2.f, -2.5f));
        camera.set_pos(vec3(8.f, 2.f, -0.f));
        camera.set_view(vec3(-1.f, 0.f, 0.f));
        camera.update_orientation(vec3(0.f, 1.f, 0.f));

        draw(renderer.models[0], camera, &output1, &par, true);
        draw(renderer.models[1], camera, &output1, &par, true);

        // draw_point(target0, camera, &output1, vec3(255.f, 0.f, 0.f));
        // draw_point(target1, camera, &output1, vec3(0.f, 0.f, 255.f));
        for(int i = 0; i < 9; i++)
        {
            draw_point(robot_bone_anim_positions1(i), camera, &output1, vec3(255.f, 0.f, 0.f));
            draw_line(robot_bone_anim_positions1(i), robot_bone_anim_positions1(i + 1), camera, &output1, vec3(255.f, 0.f, 0.f));
        }
        draw_point(robot_bone_anim_positions1(9), camera, &output1, vec3(255.f, 0.f, 0.f));

        for(int i = 0; i < 9; i++)
        {
            draw_point(robot_bone_anim_positions0(i), camera, &output1, vec3(0.f, 0.f, 255.f));
            draw_line(robot_bone_anim_positions0(i), robot_bone_anim_positions0(i + 1), camera, &output1, vec3(0.f, 0.f, 255.f));
        }
        draw_point(robot_bone_anim_positions0(9), camera, &output1, vec3(0.f, 0.f, 255.f));

        cv::imshow("left", fbo_to_img(&output0));
        cv::imshow("right", fbo_to_img(&output1));
        // output = concatenate_two_fbos(&output0, &output1, 0.5f, 0.5f);
        // cv::imshow("img", fbo_to_img(&output));
        key = cv::waitKey(1);

        // char left_name[100];
        // char right_name[100];
        // sprintf(left_name, "../../Vision_Based_Shape_Reconstruction/resources/img/zleft%d.png", t);
        // sprintf(right_name, "../../Vision_Based_Shape_Reconstruction/resources/img/zright%d.png", t);
        // cv::imwrite(left_name, fbo_to_img(&output0));
        // cv::imwrite(right_name, fbo_to_img(&output1));

        // vals(t) = compute_val(robot_bone_anim_positions0, robot_bone_anim_positions1);

        // std::cout << vals(t) << std::endl;
        // std::cout << blend << std::endl;
        std::cout << t << std::endl;
        t++;
        // print(character_bone_anim_positions(0));
        EndDrawing();
    }

    // std::ofstream outfile;
    // outfile.open("../resources/val_quat.txt");

    // for(int i = 0; i < 14641; i++)
    // {
    //     outfile << vals(i) << "\n";
    // }

    // outfile.close();
    
    return 0;
}

