extern "C"
{
#include "raylib.h"
#include "raymath.h"
}

#include "motion.hpp"
#include "character.hpp"
#include "curve.hpp"
#include "database.hpp"
#include "ik.hpp"
#include "motion.hpp"
#include "nnet.hpp"
#include "renderer.hpp"
#include "robot.hpp"
#include "simulator.hpp"

enum
{
    GAMEPAD_PLAYER = 0,
};

enum
{
    GAMEPAD_STICK_LEFT,
    GAMEPAD_STICK_RIGHT,
};

vec3 gamepad_get_stick(int stick, const float deadzone = 0.2f)
{
    float gamepadx = GetGamepadAxisMovement(GAMEPAD_PLAYER, stick == GAMEPAD_STICK_LEFT ? GAMEPAD_AXIS_LEFT_X : GAMEPAD_AXIS_RIGHT_X);
    float gamepady = GetGamepadAxisMovement(GAMEPAD_PLAYER, stick == GAMEPAD_STICK_LEFT ? GAMEPAD_AXIS_LEFT_Y : GAMEPAD_AXIS_RIGHT_Y);
    float gamepadmag = sqrtf(gamepadx * gamepadx + gamepady * gamepady);
    
    if (gamepadmag > deadzone)
    {
        float gamepaddirx = gamepadx / gamepadmag;
        float gamepaddiry = gamepady / gamepadmag;
        float gamepadclippedmag = gamepadmag > 1.0f ? 1.0f : gamepadmag * gamepadmag;
        gamepadx = gamepaddirx * gamepadclippedmag;
        gamepady = gamepaddiry * gamepadclippedmag;
    }
    else
    {
        gamepadx = 0.0f;
        gamepady = 0.0f;
    }
    
    return vec3(gamepadx, 0.0f, gamepady);
}

int main(int argc, char** argv)
{
    InitWindow(720, 720, "raylib [background]");
    SetTargetFPS(60);
    //相机
    MooCamera camera(1, 0.1f, 0.1f, 0.05f, 50.f, vec3(0.f, 0.f, 3.f), mat3(), 720, 720);
    camera.set_view(vec3(0.f, 0.f, -1.f));
    camera.update_orientation(vec3(0.f, 1.f, 0.f));
    //控制器
    Camera_Controller camera_controller;
    bind_controller(camera_controller, &camera.position, &camera.direction);
    //点光源
    Point_Light light(vec3(0.f, 1.f, 1.5f), vec3(0.f, 0.f, -1.f), vec3(20.f));
    //对角色数据的拷贝
    MooMesh mesh1 = cube();
    //材质
    MooMaterial material1(TEXTURE);
    material1.roughness = 0.1f;
    material1.tex = img_to_tex("../resources/skybox.png");
    material1.BRDFLut = img_to_tex("../resources/BRDFLut.png");
    material1.EavgLut = img_to_tex("../resources/EavgLut.png");
    //model存储mesh的拷贝，但由于mesh本身存储的是地址，实际上仍为mesh地址上的数据
    MooModel model0 = get_light_model(light);
    MooModel model1 = mesh_material_to_model(mesh1, material1);
    //更新信息
    updated_paramters par;
    par.light_dir = &light.light_direction;
    par.light_pos = &light.light_position;
    par.light_radiance = &light.light_radiance;
    par.shadow_map = light.shadow_map;
    //渲染器
    MooRenderer renderer;

    renderer.models.push_back(&model0);
    renderer.models.push_back(&model1);
    renderer.point_lights.push_back(&light);

    formation f = formation_init(15, vec3(0.f), 0.5f);
    array1d<vec3> points(11);
    points(0) = vec3(0.f, 0.f, 0.f);
    points(1) = vec3(2.f, 0.f, 0.f);
    points(2) = vec3(3.f, 0.f, 0.f);
    points(3) = vec3(4.f, 0.f, -1.f);
    points(4) = vec3(3.f, 0.f, -2.f);
    points(5) = vec3(2.f, 0.f, -1.f);
    points(6) = vec3(0.f, 0.f, -1.f);
    points(7) = vec3(-1.f, 0.f, -1.f);
    points(8) = vec3(-2.f, 0.f, 0.f);
    points(9) = vec3(-1.f, 0.f, 0.f);
    points(10) = vec3(0.f, 0.f, 0.f);
    array1d<vec3> curve_points = spine_curve(points.slice(), 0.005f);

    int key = 0;
    int frame_num = 0;
    float t = 0;
    float phase = 0;
    quat R;

    float dt = 0.0166667f;

    int times = 60;

    cv::imshow("MOOLAB", fbo_to_img(&camera.fbo[0]));

    while (key != 27 && frame_num < curve_points.size - 1)
    {
        vec3 gamepadstick_left = gamepad_get_stick(GAMEPAD_STICK_LEFT);
        vec3 gamepadstick_right = gamepad_get_stick(GAMEPAD_STICK_RIGHT);

        BeginDrawing();
        ClearBackground(RAYWHITE);

        camera.fbo[0].set(vec3(100.f, 100.f, 200.f), 100.f);

        // camera_controller.dir_gamepad_control(vec3(0.00f, 0.f, 0.f), 0.1f);
        camera.set_view(vec3(0.f, -0.99f, -0.01f));
        camera.update_orientation(vec3(0.f, 1.f, 0.f));
        camera.position = vec3(0.f, 6.f, 0.f);

        vec2 ang = dir_to_sph(curve_points(frame_num + 1) - curve_points(frame_num));
        R = quat(rad_to_deg(ang.x), vec3(0.f, 1.f, 0.f));

        if(t < 10 || (t > 20 && t < 30) || (t > 40 && t < 50))
        {
            f.formation_circle(1.f, 0.05f, 0.1f, 200, dt, curve_points(frame_num), 2.f, 2.5, R);
        }
        else
        {
            f.formation_triangle(1.f, 0.05f, 0.1f, 200, dt, curve_points(frame_num), 2.f, 3.5, R);
        }
        
        renderer.models[0]->transform = mat4(eye3(), renderer.point_lights[0]->light_position) * mat4(0.01f);
        renderer.models[1]->transform = mat4(eye3(), vec3(0.f, - 1.f, 0.f)) * mat4(5.f, 1.f, 5.f);
        
        // draw(renderer.models[0], camera, &camera.fbo[0], &par, false);
        // draw(renderer.models[1], camera, &camera.fbo[0], &par, false);
        // draw(renderer.models[0], camera, &camera.fbo[0], &par, true);
        // draw(renderer.models[1], camera, &camera.fbo[0], &par, true);
        draw_point(curve_points(frame_num), camera, &camera.fbo[0], vec3(0.f, 255.f, 0.f), 2);
        for(int i = 0; i < f.poses.size; i++)
        {
            draw_point(f.poses(i), camera, &camera.fbo[0], vec3(255.f * i / float(f.poses.size), 0.f, 0.f), 2);
        }

        cv::imshow("MOOLAB", fbo_to_img(&camera.fbo[0]));

        std::cout << " Time: " << t << " Frame: " << frame_num 
                  << std::endl;
        frame_num++;
        t = t + dt;;
        key = cv::waitKey(1);
        EndDrawing();
    }

    CloseWindow();

    return 0;
}
